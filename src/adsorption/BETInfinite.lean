import analysis.complex.basic
import data.real.basic
import algebra.ring.basic
import math.infinite_series

open_locale big_operators

/-!
# BET 
This section defines the Brunauer–Emmett–Teller (BET) adsorption theory where we relax the assumption 
of the [Langmuir model](./langmuir_kinetics.html) that restricts adsorption on a single site to be one molecule;
instead, molecules can stack on top of each other in layers.

The adsorption layers of BET are defined as infinite sequence with zeroth layer as constant and is expressed as:

where:

- `x` is
- `s₀` is
- `C` is


### Assumptions


### Constraints generated by Lean


### To-Do
- 
-/



section BET
variables (x s₀ C: ℝ)

-- The main BET sequence
def seq : ℕ → ℝ
|(0 : ℕ)            := s₀
|(nat.succ n) := x^(n+1)*s₀*C

--the main math of BET
theorem BET₁ (C : ℝ) (hx1: x < 1) (hx2 : 0 < x) (hs : s₀ ≠ 0):
  (∑' i : ℕ, ((i + 1 : ℝ)*(seq x s₀ C (i+1:ℕ))))/(s₀ + ∑' i, (seq x s₀ C (i+1:ℕ))) = C*x/((1 - x)*(1 - x + x*C)) :=  
begin
  simp [seq],
  have hxnorm : ∥x∥ < 1, by refine abs_lt.mpr ⟨_, _⟩ ; linarith,
  simp [← mul_assoc],
  rw [tsum_mul_right, tsum_mul_right, tsum_mul_right, tsum_mul_right, tsum_coe_mul_geometric_succ hx1 hx2, 
  tsum_geometric_of_lt_1_pow_succ hx1 hx2, pow_two],
  have h1 : (1-x) ≠ 0 := by linarith,
  field_simp,
  rw [mul_comm, mul_assoc (1-x) _ _, mul_div_mul_left, mul_comm, mul_comm x s₀, mul_comm C _, mul_assoc s₀ x C, 
  ← mul_add s₀ _ _, ← mul_assoc (1-x) _ _,  mul_comm _ s₀, mul_assoc s₀ _ _, mul_div_mul_left, mul_comm C x],
  iterate 2 {finish},
end

/-BET given in a form that is similar to something that would be derived by symbolic regression. 
We want this for use with our Bayesian symbolic regression group  -/
theorem BET_regression_form
{V₀ y : ℝ}
-- Constraints
(hx1: x<1)
(hx2 : 0 < x)
(hs : s₀ ≠ 0)    -- S₀ is the surface area, covered by 0 layers of adsorbed molecules
(hV : V₀ ≠ 0)    -- V₀ is the volum of gas adsorbed
:
  let
      A := ∑' (k : ℕ), (seq x s₀ C k),               -- Eq (13)
      Vads :=  V₀ * ∑' (k : ℕ), ↑k * (seq x s₀ C k), -- Eq (14)
      Vm := V₀ * A in
  Vads/Vm = C*x/((1 - x)*(1 - x + C*x))              -- Eq (26)
:=
begin
intros,
  have hsum2 : summable (seq x s₀ C),
  { refine (summable_nat_add_iff 1).mp _,
    simp only [seq, pow_succ', mul_assoc],
    exact (summable_geometric_of_lt_1 hx2.le hx1).mul_right _ },
  have hxnorm : ∥x∥ < 1, by refine abs_lt.mpr ⟨_, _⟩ ; linarith,
  have hsum : summable (λ i : ℕ, ↑i * (seq x s₀ C i)),
  { refine (summable_nat_add_iff 1).mp _,
    simp only [seq, ← mul_assoc],
    refine summable.mul_right _ (summable.mul_right _ _),
    set u := λ i :ℕ, (i : ℝ) * x ^ i,
    change summable (λ (n : ℕ), u (n+1)),
    refine (summable_nat_add_iff 1).mpr _,
    simpa using summable_pow_mul_geometric_of_norm_lt_1 1 hxnorm },
  simp only [Vads, A, Vm],
  rw [tsum_eq_zero_add hsum, tsum_eq_zero_add hsum2, mul_div_mul_left],
  simp only [nat.cast_zero, zero_mul, zero_add, nat.cast_one, pow_zero, one_mul, mul_assoc, nat.cast_add, mul_div_assoc],
  rw [show seq x s₀ C 0 = s₀, by {simp [seq]}], 
  rw [BET₁ x s₀ C hx1 hx2 hs, ← mul_div_assoc,mul_comm x C ],
  exact hV,
end
