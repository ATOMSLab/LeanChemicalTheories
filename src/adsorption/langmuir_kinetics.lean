import analysis.calculus.lhopital
import order.filter.at_top_bot




/-!
# Langmuir adsorption model
This section defines Langmuir adsorption model from kinetics for a single adsorbate on a single site: <br>
$$
θ = \frac{K Pₐ}{1  +  K Pₐ} 
$$
where:
- `θ` is the fractional occupancy of the adsorption sites
- `K` is the adsorption constant describing the adsorption/desorption rates in equilibrium
- `Pₐ` is the partial pressure of the adsorbate

### Assumption
The model assumes the rate of adsorption `r_ad = k_ad * Pₐ * S` and <br> 
the rate of desorption `r_d = k_d * A` are equal at equilibrium conditions where:
- `k_ad` is the adsorption constant
- `k_d` is the desorption constant
-  `S` is the concentartion of all sites
- `A` is the concentartion of occupied sites

### Constraints generated by Lean
- `S ≠ 0`
- `k_d ≠ 0`


### To-Do
- Proof statistical mechanical derivation of the model
- Generalize proof from properties of system
-/

theorem Langmuir_single_site_old
(Pₐ k_ad k_d A S : ℝ)
(hreaction : let r_ad := k_ad*Pₐ*S, r_d := k_d*A in r_ad = r_d) 
(hS : S ≠ 0)
(hk_d : k_d ≠ 0)
: 
let θ := A/(S+A),
    K := k_ad/k_d in 
θ = K*Pₐ/(1+K*Pₐ) :=
begin
  simp at hreaction,
  rw [mul_comm k_d A, ← div_eq_div_iff hk_d hS] at hreaction,
  field_simp [hreaction],
end

noncomputable
def langmuir_single_site_model (equilibrium_constant : ℝ) : ℝ → ℝ := λ P : ℝ, equilibrium_constant*P/(1+equilibrium_constant*P)
def hernys_law_model (equilibrium_constant : ℝ) : ℝ → ℝ := λ P, equilibrium_constant*P


theorem langmuir_single_site_kinetic_derivation
{Pₐ k_ad k_d A S : ℝ}
(hreaction : let r_ad := k_ad*Pₐ*S, r_d := k_d*A in r_ad = r_d) 
(hS : S ≠ 0)
(hk_d : k_d ≠ 0)
:
let θ := A/(S+A),
    K := k_ad/k_d in 
θ = langmuir_single_site_model K Pₐ :=
begin
  simp [langmuir_single_site_model] at *,
  rw [mul_comm k_d A, ← div_eq_div_iff hk_d hS] at hreaction,
  field_simp [hreaction],
end

lemma lhopital_at_top_div_at_top_transformation
(f g : ℝ → ℝ)
(l : filter ℝ)
: filter.tendsto (λ x, f x / g x) l = filter.tendsto ((λ x, (1 / g x) / (1 / f x))) l := by simp

theorem langmuir_approx_henry_law_at_low_pressure
{k_ad k_d : ℝ}
(hk_ad : 0 < k_ad)
(hk_d : 0 < k_d)
: filter.tendsto ((langmuir_single_site_model (k_ad/k_d))/(hernys_law_model (k_ad/k_d))) (nhds_within 0 (set.Ioi 0)) (nhds 1) :=
begin
  simp [langmuir_single_site_model, hernys_law_model],
  apply deriv.lhopital_zero_nhds_right,
  { rw filter.eventually_iff_exists_mem,
    use (set.Ioi (0 : ℝ)),
    split,
    exact self_mem_nhds_within,
    intros,
    simp,
    apply differentiable_at.div,
    any_goals {simp},
    simp at H,
    apply ne_of_gt,
    apply add_pos,
    exact zero_lt_one,
    apply mul_pos (div_pos hk_ad hk_d) H,},
  { rw filter.eventually_iff_exists_mem,
    use (set.Ioi (0 : ℝ)),
    split,
    exact self_mem_nhds_within,
    intros,
    simp,
    apply not_or (ne_of_gt hk_ad) (ne_of_gt hk_d),},
  { simp,
    rw nhds_within,
    apply filter.tendsto_inf_left,
    rw [show (0 : ℝ) = 0/1, by norm_num, show (λ (x : ℝ), k_ad / k_d * x / (1 + k_ad / k_d * x)) = (λ (x : ℝ), k_ad / k_d * x) /  (λ x, (1 + k_ad / k_d * x)), by finish],
    apply filter.tendsto.div,
    rw show 0 = (k_ad/k_d * 0), by simp,
    apply filter.tendsto.const_mul,
    finish,
    rw show nhds (1 : ℝ) = nhds (1 + 0), by simp,
    apply filter.tendsto.const_add,
    rw show 0 = (k_ad/k_d * 0), by simp,
    apply filter.tendsto.const_mul,
    finish,
    exact zero_ne_one.symm,},
  { rw nhds_within,
    apply filter.tendsto_inf_left,
    rw show 0 = (k_ad/k_d * 0), by simp,
    apply filter.tendsto.const_mul,
    finish,},
  simp,
  
end

theorem langmuir_zero_loading_at_zero_pressure
{k_ad k_d : ℝ}
: langmuir_single_site_model (k_ad/k_d) 0 = 0 :=
begin
  field_simp [langmuir_single_site_model],
end


theorem langmuir_single_site_finite_loading
{k_ad k_d : ℝ}
(hk_ad : 0 < k_ad)
(hk_d : 0 < k_d)
: filter.tendsto (langmuir_single_site_model (k_ad/k_d)) filter.at_top (nhds (1 : ℝ)):=
begin
  simp [langmuir_single_site_model],
  have hk_ad1 : k_ad ≠ 0 := ne_of_gt hk_ad,
  have hk_d1 : k_d ≠ 0 := ne_of_gt hk_d,

  -- rw lhopital_at_top_div_at_top_transformation,
  -- apply deriv.lhopital_zero_at_top,
  -- { rw filter.eventually_iff_exists_mem,
  --   use ({-k_d/k_ad}ᶜ),
  --   rw filter.mem_at_top_sets,
  --   split,
  --   use (-k_d/k_ad + 1),
  --   intros,
  --   apply ne_of_gt,
  --   have h : -k_d/k_ad < -k_d/k_ad + 1 := by simp,
  --   exact lt_of_lt_of_le h H,
  --   intros,
  --   apply differentiable_at.div (differentiable_at_const (1 : ℝ)),
  --   simp [differentiable_at.const_add],
  --   simp at H,
  --   field_simp,
  --   field_simp at H,
  --   rw [add_comm, add_eq_zero_iff_eq_neg],
  --   ring,
  --   exact H,},
  -- { rw filter.eventually_iff_exists_mem,
  --   use (set.Ioi (0)),
  --   rw filter.mem_at_top_sets,
  --   split,
  --   use (k_d/k_ad),
  --   intros,
  --   simp,
  --   apply lt_of_lt_of_le _ H,
  --   rw lt_div_iff hk_ad,
  --   simpa using hk_d,
  --   intros,
  --   simp,
  --   push_neg,
  --   have h : y ≠ 0,
  --   { simp at H,
  --     apply ne_of_gt, exact H,
  --     },
  --   exact ⟨h, hk_d1, hk_ad1⟩,
  --   },
  --   { apply filter.tendsto.div_at_top tendsto_const_nhds,
  --     apply filter.tendsto_at_top_add_const_left,
  --     apply filter.tendsto.const_mul_at_top,
  --     rw lt_div_iff hk_d,
  --     simpa using hk_ad,
  --     finish,
  --     exact real.order_topology,
  --     exact real.topological_ring.to_topological_semiring.to_has_continuous_mul,},
  --   { apply filter.tendsto.div_at_top tendsto_const_nhds,
  --     apply filter.tendsto.const_mul_at_top,
  --     rw lt_div_iff hk_d,
  --     simpa using hk_ad,
  --     finish,
  --     exact real.order_topology,
  --     exact real.topological_ring.to_topological_semiring.to_has_continuous_mul,},
  --   { have hderiv1 : λ (x : ℝ), deriv (λ (x : ℝ), 1 / (1 + k_ad / k_d * x)) x
  --     },
end

